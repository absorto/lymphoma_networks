#NOTAS:
# con tabulador autocompletas.
# example(plot): da un ejemplo de la función.
# cursera: página de internet con cursos gratis.
# complexity explorer: curso universidad santa fe.
# paquetes por Bioconductor (no con instal.packages): biocLite("package").

#####################################################################################
##Script para normalizar, sacado de:
##http://bioinformatics.knowledgeblog.org/2011/06/20/analysing-microarray-data-in-bioconductor/
source("http://bioconductor.org/biocLite.R")
biocLite("affy")
biocLite ("limma")
biocLite ("gplots")
library(affy)
library(limma, gplots)
biocLite("GEOquery")
library(GEOquery)
data<-setwd("C:/Program Files/R/RData")
untar("GSE17189/GSE17189_RAW.tar")
biocLite("simpleaffy")
library(simpleaffy)
datos <- ReadAffy()
sampleNames(datos)
head(exprs(datos))
pData(datos)<-read.table("phenodata.txt", header=T, row.names=1, sep="\t")
celfiles<-datos
#Normalizando
#gcrma: This function converts an AffyBatch into an ExpressionSet using the robust multi-array average (RMA) expression measure with help of probe sequence.
celfiles.gcrma <- gcrma(celfiles)
# load colour libraries
install.packages("RColorBrewer")
library(RColorBrewer)
# set colour palette
cols <- brewer.pal(8, "Set1")
# plot a boxplot of unnormalised intensity values
boxplot(celfiles, col=cols)
# plot a boxplot of normalised intensity values, affyPLM is required to interrogate celfiles.gcrma
biocLite("affyPLM")
library(affyPLM)
boxplot(celfiles.gcrma, col=cols)
# the boxplots are somewhat skewed by the normalisation algorithm
# and it is often more informative to look at density plots
# Plot a density vs log intensity histogram for the unnormalised data
hist(celfiles, col=cols)
# Plot a density vs log intensity histogram for the normalised data
hist(celfiles.gcrma, col=cols)

# Perform probe-level metric calculations on the CEL files:
celfiles.qc <- fitPLM(celfiles)
# Create an image of GSM429903.CEL:
image(celfiles.qc, which=1, add.legend=TRUE)
# Create an image of GSM524665.CEL
> # There is a spatial artifact present
> image(celfiles.qc, which=4, add.legend=TRUE)
> # affyPLM also provides more informative boxplots
> # RLE (Relative Log Expression) plots should have
> # values close to zero. GSM524665.CEL is an outlier
> RLE(celfiles.qc, main="RLE")
> # We can also use NUSE (Normalised Unscaled Standard Errors).
> # The median standard error should be 1 for most genes.
> # GSM524665.CEL appears to be an outlier on this plot too
> NUSE(celfiles.qc, main="NUSE"


#################################################################################
#Rutina del manual de Rangel.
#Instalar bioconductor
source("http://bioconductor.org/biocLite.R")
biocLite()
## affy: es un conjunto de funciones útiles para gráficos, normalización, corrección de
### fondo e integración de datos de microarreglos de expresión. Escencial en el análisis
source("http://bioconductor.org/biocLite.R")
biocLite("affy")
biocLite ("limma")
biocLite ("gplots")
library(affy)
library(limma, gplots)
biocLite("GEOquery")
library(GEOquery)
#Para analizar los datos GSE17189
data<-setwd("C:/Program Files/R/RData")
untar("GSE17189/GSE17189_RAW.tar")
datos <- ReadAffy()
datos
#Para ver el nombre de los datos extraídos
sampleNames(datos)
#Para la exploración visual de los diferentes archivos (17)
mycolors<- rep(c("blue","red","green", "magenta"), each = 1)
hist(datos, col=mycolors, main="Distribución de Datos Crudos")
boxplot(datos, col=mycolors, main="Distribución de Datos Crudos")
par(mfrow=c(3,2))
hist(datos[,1:3], col=c("blue","red","green"))
hist(datos[,4:6], col=c("blue","red","green"))
hist(datos[,7:9], col=c("blue","red","green"))
hist(datos[,10:12], col=c("blue","red","green"))
hist(datos[,13:15], col=c("blue","red","green"))
hist(datos[,16:17], col=c("blue","red","green"))
layout(1)

#Normalización
datos.norm = datos
for (i in c(1,4,7,10,13,16))
{
  qnorm= normalize(datos[,i:(i+2)], method="quantiles")
  for (j in 1:3)
  {
    pm(datos.norm)[,i+j-1] = pm(qnorm)[,j]
    mm(datos.norm)[,i+j-1] = mm(qnorm)[,j]
  }
}

eset <- expresso(datos.norm, bgcorrect.method="none", normalize= FALSE, pmcorrect.method="pmonly", summary.method="medianpolish")
eset.loess <- expresso(datos.norm, bgcorrect.method="none", normalize.method="loess", pmcorrect.method="pmonly",summary.method="medianpolish")
eset.quantiles <- expresso(datos.norm, bgcorrect.method="none",normalize.method="quantiles" , pmcorrect.method="pmonly",summary.method="medianpolish")
gexlev = data.frame(exprs(eset))
plotDensity(exprs(eset), col=mycolors, main="Sin normalizar")
plotDensity(exprs(eset.loess), col=mycolors, main="Despues de normalizar")
plotDensity(exprs(eset.quantiles), col=mycolors, main="Despues de normalizar")

nivelesExp = data.frame(exprs(eset))
write.csv(nivelesExp, file=’NivelesExpresion.csv’)


##########################
#MÉTODOS DE NORMALIZACIÓN
## COMANDO "expresso", PAQUETE "affy"
### Bajo el comando "normalize.method" existen estas opciones:
####"constant"
####"contrasts"
####"invariantset"
####"loess"           
####"methods"
####"qspline"
####"quantiles"
####"quantiles.robust"


#MÉTODOS DE NORMALIZACIÓN
## COMANDO "gcrma", PAQUETE "gcrma"
### Normaliza usando el método "quantile normalization".


















